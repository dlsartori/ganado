# from __future__ import annotations
# from dataclasses import dataclass
import datetime
import datetime as dt
import hashlib
import itertools as it
import collections
import threading
from random import randint, random
from krnl_db_access import setrecords
from uuid import UUID, uuid4
import re
import pandas as pd
from krnl_asset import Asset
from krnl_entityObject import *
from krnl_abstract_class_activity import Activity, activityEnableFull, sessionActiveUser, valiDate
# from krnl_abstract_method_factory import ActivityMethod
from krnl_abstract_class_prog_activity import ProgActivity
from krnl_config import krnl_logger, bkgd_logger, SPD, TERMINAL_ID, MAX_GOBACK_DAYS, db_str_separator, \
    PANDAS_READ_CHUNK_SIZE
from krnl_animal_activity import AnimalActivity, InventoryActivityAnimal, StatusActivityAnimal, TagActivityAnimal, \
    LocalizationActivityAnimal, TMActivityAnimal, PersonActivityAnimal, ProgActivityAnimal, GenericActivityAnimal
from krnl_animal_activity_alta_baja import AltaActivityAnimal
# from krnl_health import Application
# from krnl_tag import Tag
from krnl_tag_animal import TagAnimal, Tag, TagMammal, TagBird
from krnl_tag_tech_classes import *  # TODO:Must load module here to run initialization code for Tag Technology Classes.
from krnl_custom_types import getRecords

def moduleName():
    return str(os.path.basename(__file__))

# Abstract Class: Cannot instantiate Animal. Only subclasses can.
class Animal(Asset):
    __slots__ = ('_fldDOB', '_fldMF', '_fldFlagCastrado', '_fldAnimalClass', '_fldFK_Raza', '__countMe', '__exitDate',
                 '_name', '_animalClassName', '_mode', '_conceptionType', '__surrogateMother', '_timeStamp',
                 '__myTags', '__comment', 'ageDays', '__identifiers', '_tags_read')
    __classesEnabled = {1: True, 2: False, 3: False, 4: False, 5: False}  # Class of Animals to register
    __MIN_REWIND_DAYS = 365        # Tiempo en Dias. Usado en generateDOB().
    # __lock = Lock()
    _animal_items = []      # Temporary structure to run updateTimeout_bkgd()

    # TODO(cmt): Defining _activityObjList will call  _creatorActivityObjects() in EntityObject.__init_subclass__().
    _activityObjList = []  # List of Activity objects created by factory function.
    _myActivityClass = AnimalActivity       # Used to initialize dicts for memory_data handling, among other things..

    __tblObjName = 'tblAnimales'
    __tblObjectsName = __tblObjName
    __tblRADBName = _myActivityClass.tblRADBName()
    __tblLinkDBName = _myActivityClass.tblLinkDBName()
    __tblObjDBName = getTblName(__tblObjName) or ''

    @classmethod
    def tblRAName(cls):
        return cls._myActivityClass.tblRAName()
    @classmethod
    def tblRADBName(cls):
        return cls._myActivityClass.tblRADBName()

    @classmethod
    def tblObjName(cls):
        return cls.__tblObjName

    @classmethod
    def tblObjDBName(cls):
        return cls.__tblObjDBName

    # __activityClasses = {}  # {animalKind(string): class, } -> Cada class de Activity() inserta aqui sus datos
    # {Animal mode: count value, }
    __animalMode = {'regular': 1, 'substitute': 0, 'dummy': -1, 'external': 0, 'generic': 0, 'unreplicated': 1}
    __conceptionTypes = ('natural', 'ia', 'inseminacion', 'inseminacion artificial', 'te', 'transferencia embrionaria')
    __animalClasses = {}
    __RATriggerName = "Trigger_Animales Registro De Actividades_INSERT"
    __AnimalesTriggerName = "Trigger_Animales_INSERT"

    @classmethod
    def _processReplicated(cls):  # cls is Animal. TODO: Processes Animales Registro De Actividades replicated records.
        """                 ******** Runs out of an Async Buffer queue *************
        Used to execute logic for management of Record replication in Table Animales Registro De Actividades.
        Defined here because it runs processExecutedActivity, which in turn MUST be defined here because it accesses
        _activityObjList[].
        The main concept is that only nodes that created a ProgActivity will close that ProgActivity, for gains in
        consistency and simplicity. With this requirement, each node must process Activities generated by other nodes
        and use those replicated Activities that may be a closure for a ProgActivity created by the local node.
        **** For now, only Animales define ProgActivities and need to process RA Replication. Tags definitely NOT. ****
        @return: True if update operation succeeds, False if reading tblAnimalesRegistroDeActividades from db fails.
        """
        sql_replication = f'SELECT * FROM _sys_Trigger_Tables WHERE Trigger_Name == "{cls.__RATriggerName}" AND ' \
                          f'ROWID == Flag_ROWID; '
        tempdf = pd.read_sql_query(sql_replication, SQLiteQuery().conn)  # Only 1 record (for Terminal_ID) is pulled.
        if not tempdf.empty:
            updated_by = set(tempdf.loc[0, 'fldUpdated_By'])  # removes any duplicates if present.
            updated_by_copy = updated_by.copy()  # Updated_By list is modified inside the loop. Must use a copy in loop.
            time_stamp = tempdf.loc[0, 'fldTimeStamp'] or time_mt('dt')
            if time_stamp > (tempdf.loc[0, 'fldLast_Processing'] or 0):
                for j in updated_by_copy:
                    # The loop will traverse ALL animal kinds found in updated_by list and update their RA records and
                    # run processExecutedActivity() for each class listed.
                    try:
                        animalClassID = int(j)
                    except (ValueError, TypeError):
                        continue
                    else:
                        animal_cls = next((k for k, v in cls.getAnimalClasses().items() if v == animalClassID), None)
                    """ Processes RA replicates for Animales RA: processExecutedActivity(). animal_cls is Bovine, 
                    Caprine. etc. """
                    if animal_cls and hasattr(animal_cls, 'processExecutedActivity'):
                        animal_cls.processExecutedActivity()
                        # Updates record in _sys_Trigger_Tables to reflect last processing done with time = TimeStamp
                        updated_by.discard(j)
                        print(f'PROCESSREPLICATED DISCARDED {j} - updated_by: {updated_by}')

            if len(updated_by) != len(updated_by_copy):
                # TODO(cmt): VERY IMPORTANT. _sys_Trigger_Tables.Last_Processing MUST BE UPDATED here before exiting.
                _ = setRecord('tbl_sys_Trigger_Tables', fldID=tempdf.loc[0, 'fldID'], fldLast_Processing=time_stamp,
                              fldUpdated_By=tuple(updated_by))
                return True
        return None

    @classmethod
    def _processDuplicates(cls):  # Run by Bovine, Caprine, etc. Also for Caravanas, Geo, Personas in other classes.
        """             ******  Run out of an AsyncCursor queue. NO PARAMETERS ACCEPTED FOR NOW. ******
                        ******  Run periodically as an IntervalTimer func. ******
                        ****** This code should (hopefully) execute in LESS than 5 msec (switchinterval).   ******
        Re-loads duplication management dicts for class cls.
        @return: True if update operation succeeds, False if reading tblAnimales from db fails or nothing is processed.
        """
        sql_duplication = f'SELECT * FROM _sys_Trigger_Tables WHERE DB_Table_Name == "{cls.tblObjDBName()}" AND ' \
                          f'ROWID == Flag_ROWID; '
        tempdf = pd.read_sql_query(sql_duplication, SQLiteQuery().conn)   # Only 1 record (for Terminal_ID) is pulled.
        # if isinstance(temp, DataTable) and temp:
        values_list = tempdf.loc[0,  "fldUpdated_By"] or set()
        # print(f'hhhhhhooooooooooolaa!! "{cls.tblObjDBName()}".processDuplicates. values_list  = {values_list}!!')
        values_list = set(values_list)  # Removes all duplicate values.
        time_stamp = tempdf.loc[0, 'fldTimeStamp'] or time_mt('dt')     # time of the latest update to the table.
        values_list_copy = values_list.copy()       # values_list is modified in for loop. Must use a static copy.

        for j in values_list_copy:
            try:
                class_id = int(j)
            except (ValueError, TypeError):
                class_id = None
            animal_class = next((k for k in cls.getAnimalClasses() if cls.getAnimalClasses()[k] == class_id), None)
            if animal_class:
                try:
                    animal_class._init_uid_dicts()      # Reloads uid_dicts for class with id = class_id
                    print(f'hhhhhhooooooooooolaa!! Animal.processDuplicates() Just updated _active_uid_dicts!!.'
                          f'animal_class = {animal_class}')
                except AttributeError:
                    pass
                else:
                    # If dicts are processed, remove animalClassID items from db _sys_Trigger_Table.
                    values_list.discard(j)

        # Updates record in _sys_Trigger_Tables if with all entries for table just processed removed.
        # TODO(cmt): VERY IMPORTANT. _sys_Trigger_Tables.Last_Processing MUST BE UPDATED here before exiting.
        if len(values_list) != len(values_list_copy):    # Updates row in _sys_Trigger_Tables.
            tempdf.loc[0, ('fldUpdated_By', 'fldLast_Processing')] = (values_list, time_stamp)
            _ = setRecord('tbl_sys_Trigger_Tables', **tempdf.loc[0].to_dict())
            return True
        return None

    __trig_name_replication = __RATriggerName           # Replication Trigger
    __trig_name_duplication = __AnimalesTriggerName     # DUPLICATION Trigger

    # List here ALL triggers defined for Animales table. Triggers can be functions (callables) or str.
    # TODO: Careful here. _processXXX__func__ are stored as UNBOUND methods. Must be called as _processXXX__func__(cls)
    # Name-mangling (by using __db_triggers_list) to avoid unwanted inheritance for triggers.
    __db_triggers_list = [(__trig_name_replication, _processReplicated),
                          (__trig_name_duplication, _processDuplicates)]

    @classmethod
    def obj_mem_fields(cls):                    # cls sn Bovine, Caprine, etc.
        return cls._object_mem_fields           # Access DataFrame struct. in respective class.

    @classmethod
    def obj_dataframe(cls):                     # cls sn Bovine, Caprine, etc.
        with cls._sem_obj_dataframe:                    # tee() is not thread safe.
            # Produces 2 iterators: 1 to replenish the exhausted _active_uids_df; 1 to return to caller.
            ittr = it.tee(cls._active_uids_df, 2)
            cls._active_uids_df = ittr[0]
        return ittr[1]


    @classmethod
    def obj_dupl_series(cls):
        return cls._dupl_series                 # Access DataFrame struct. in respective class.


    @classmethod
    def resolve_duplicates(cls, uid: str = None):
        """Returns a single value or a set of UIDs associated to uid_list by duplication
        @param uid: Object uid (fldObjectUID field).
        @return: set of UIDs unique values (duplicated due to table replication). If one uid, returns a set of 1 {val, }
        for compatibility of processing the result.
        """
        if uid:
            # all_duplicate=True is used for specific actions (ex: pulling ALL Inventory, Status or Sanitation records)
            return cls._get_duplicate_uids(uid, all_duplicates=True)
        return ()

    @classmethod
    def get_identifiers(cls, obj_uid=''):
        """Returns list of identifiers for obj_uid, or () if none found. """
        for df in cls.obj_dataframe():
            try:
                retlist = df.loc[df['fldObjectUID'] == obj_uid, 'fldIdentificadores']
            except (ValueError, TypeError, SyntaxError):
                continue
            else:
                if len(retlist.index) > 0:
                    return retlist.iloc[0]
        return ()

    @classmethod                # Implements DataFrames and non-replicated objects logic using checksums.
    def getObject(cls, obj_uid=None, *, identifier=None, load_identifiers=False, fetch_from_db=False):
        # TODO 05Aug24: Include logic to create and handle unreplicated objects.
        """ Returns Animal object associated to name if provided or searches by identfier. cls is Bovine, Caprine, etc.

        @param load_identifiers: creates Tag objects attached to object and adds them to obj attributes. Default:False.
        @param obj_uid: Animal UID (string).
        @param identifier: can be a Tag UUID or a regular human-readable string (Tag Number for Animals).
        @param fetch_from_db: Ignores memory data (_active_uids_df) and reads data from db.
        Tags are normalized (removal of accents, dieresis, special characters, convert to lowercase) before processing.
        @return: Animal object if any found, None if none found for that obj_uid or identifier.
        Duplication-aware: YES
        """
        animalTags = []
        if obj_uid and isinstance(obj_uid, str):
            try:
                animal_uid = UUID(obj_uid.strip()).hex      # hex converts UUID to str.
            except (SyntaxError, ValueError, TypeError):
                return None
        elif identifier:                # identifier is a uid for Tag objects.
            if not hasattr(identifier, '__iter__'):
                identifier = tuple(identifier)
            animalTags = [cls._myTagClass().getObject(i) for i in identifier]
            animalTags = [t for t in animalTags if isinstance(t, Tag)]
            animal_uid = None
            # Pull animal uid from Animales table, using fldIdentifiers.
            for t in animalTags:
                found = False
                for df in cls.obj_dataframe():
                    auxdf = df[['fldObjectUID', 'fldIdentificadores']].explode('fldIdentificadores')
                    mask = auxdf[auxdf.isin([t.ID])['fldIdentificadores']]
                    try:
                        animal_uid = df.loc[df['fldObjectUID'].isin(mask['fldObjectUID'].to_list()), 'fldObjectUID']
                    except (SyntaxError, ValueError, TypeError):
                        continue
                    else:
                        if animal_uid is not None:
                            if len(animal_uid.index) == 1:
                                animal_uid = animal_uid.iloc[0]  # Pulls 1st item from pd.Series.
                                found = True        # Exits loop upon finding the 1st non-null animal_uid
                            elif len(animal_uid) > 1:
                                raise ValueError(f'ERR_ValueError: tag {t.tagNumber} is assigned to multiple animals. '
                                                 f'Exiting.')
                            else:
                                animal_uid = None  # TODO: CHECK THIS VALUE!!
                                continue
                    if found:
                        break
        else:
            return None

        if animal_uid:
            # The func. below with no other arguments gets the Original uid if duplicates exist, None if no duplicates.
            # With all_duplicates=True returns a tuple with all the UIDs of duplicates objects associated to animal_uid.
            # Returns None or () if no duplicates, hence the "or "
            dupl_uids = cls._get_duplicate_uids(animal_uid, all_duplicates=True) or (animal_uid,)
            uid_nor = cls._get_duplicate_uids(animal_uid) or animal_uid     # NOR: Node Original Record (same as EDR).
            if not fetch_from_db:
                # Fetches data from memory (_init_uids_df iterator)
                df = None
                for frame in cls.obj_dataframe():
                    aux = frame[frame['fldObjectUID'].isin(dupl_uids)]      # db Accessor settings are lost in aux.
                    if not aux.empty:
                        if df is None:      # All this coding to retain the db Accessor values for resulting df.
                            df = pd.DataFrame.db.create(frame.db.tbl_name, data=aux.to_dict())
                        else:
                            df.append(aux, ignore_index=True)       # uses append to retain db Accessor settings in df.
                if df is None:
                    fetch_from_db = True        # No data in memory, forces retrieval from db.

            if fetch_from_db:
                # Fetches data from db.
                if dupl_uids != (animal_uid,):
                    # There are duplicates: pulls data using fld_Duplication_Index.
                    sql = f'SELECT * FROM "{cls.__tblObjDBName}" WHERE ' \
                          f'"{getFldName(cls.tblObjName(), "fld_Duplication_Index")}" IN ' \
                          f'{str(dupl_uids) if len(dupl_uids) > 1 else str(dupl_uids).replace(",", "")}; '
                else:
                    # No duplicates: fld_Duplication_Index may be empty. Pulls data using fldObjectUID.
                    sql = f'SELECT * FROM "{cls.__tblObjDBName}" WHERE ' \
                          f'"{getFldName(cls.tblObjName(), "fldObjectUID")}" IN ' \
                          f'{str(dupl_uids) if len(dupl_uids) > 1 else str(dupl_uids).replace(",", "")}; '
                df = pd.read_sql_query(sql, SQLiteQuery().conn)  # df contains all duplicate records (if any) or just 1.

            if not df.empty:
                # Get checksum from Node Original Record (also called EDR) and compare to data just read into df.
                # All this logic to update the memory dataframe with any new data appearing on tblOjbect.
                # TODO(cmt): NOR is the only record in the table with fldObjectUID = _Duplication_Index (by design)
                #  NOR: Node Original Record
                # nor_idx = df[df['fld_Duplication_Index'] == uid_nor].index[df['fld_Duplication_Index'] ==
                #                                                             df['fldObjectUID']].tolist()[0]
                nor_idx = df[df['fldObjectUID'] == uid_nor].index[0]
                nor_checksum = df.loc[nor_idx, 'fld_Update_Checksum']
                # Removes the checksum column from the checksum computation so that checksum is valid. Also sets all
                # null values to None BEFORE computating checksum so that it's consistent with value read from db.
                df.fillna(np.nan).replace([np.nan], [None], inplace=True)
                new_checksum = hashlib.sha256(df.drop('fld_Update_Checksum',axis=1).to_json().encode()).hexdigest()
                if nor_checksum != new_checksum:
                    # Values have changed for the duplicate records associated to animal_uid. Must reload from db.
                    # Updates row check sum and writes nor record to db (the only record modified here).
                    df.loc[nor_idx, 'fld_Update_Checksum'] = new_checksum
                    # Updates the correct db record regardless of nor_idx, as fldID remains unchanged throughout.
                    _ = setRecord(cls.tblObjName(), **df.loc[nor_idx, :].to_dict())  # Writes to db if changes found.
                    # After setRecord(), must reload full data from db since _active_uids_df is an iterator and cannot
                    # be updated on a single-record basis.
                    cls._init_uid_dicts()

                # Creates Animal object with all the data compiled in EDR (If any new data was found among duplicates).
                obj = cls(**df.loc[nor_idx].to_dict())
                if animalTags:
                    obj.tags_read = animalTags  # Sets up all tags scanned to id the Animal. Thread-safe dict.
                if load_identifiers:             # Creates BovineTag, CaprineTag objects and assigns them to obj.
                    identifs = obj.getIdentifiers()
                    if identifs:
                        obj.setMyTags(*[obj._myTagClass().getObject(i) for i in identifs])
                return obj   # Original Object uid found. cls object returned.

        # Returning None means no duplicates for the uid (99.9% of the cases for each object table, hopefully)
        return None


    # @classmethod
    # def getObject02(cls, obj_uid=None, *, identifier=None, load_identifiers=False):     # NO SUPPORT FOR ITERATORS.
    #     """ Returns Animal object associated to name if provided or searches by identfier. cls is Bovine, Caprine, etc.
    #     @param load_identifiers: creates Tag objects attached to object and adds them to obj attributes. Default:False.
    #     @param obj_uid: Animal UID (string).
    #     @param identifier: can be a Tag UUID or a regular human-readable string (Tag Number for Animals).
    #     Tags are normalized (removal of accents, dieresis, special characters, convert to lowercase) before processing.
    #     @return: Animal object if any found, None if none found for that obj_uid or identifier.
    #     Duplication-aware: YES
    #     """
    #     animalTags = []
    #     objdf = cls.obj_dataframe()
    #     if obj_uid and isinstance(obj_uid, str):
    #         try:
    #             animal_uid = UUID(obj_uid.strip()).hex      # hex converts UUID to str.
    #         except (SyntaxError, ValueError, TypeError):
    #             return None
    #     elif identifier:                # identifier is a uid for Tag objects.
    #         if not hasattr(identifier, '__iter__'):
    #             identifier = tuple(identifier)
    #         animalTags = [cls._myTagClass().getObject(i) for i in identifier]
    #         animalTags = [t for t in animalTags if isinstance(t, Tag)]
    #         animal_uid = None
    #         # Pull animal uid from Animales table, using fldIdentifiers.
    #         for t in animalTags:
    #             auxdf = objdf[['fldObjectUID', 'fldIdentificadores']].explode('fldIdentificadores')
    #             mask = auxdf[auxdf.isin([t.ID])['fldIdentificadores']]
    #             try:
    #                 animal_uid = objdf.loc[objdf['fldObjectUID'].isin(mask['fldObjectUID'].to_list()), 'fldObjectUID']
    #             except (SyntaxError, ValueError, TypeError):
    #                 continue
    #             else:
    #                 if animal_uid is not None:
    #                     if len(animal_uid) == 0:
    #                         animal_uid = None       # TODO: CHECK THIS VALUE!!
    #                         break
    #                     elif len(animal_uid) > 1:
    #                         raise ValueError(f'ERR_ValueError: tag {t.tagNumber} is assigned to multiple animals. '
    #                                          f'Exiting.')
    #                     else:
    #                         animal_uid = animal_uid[0]      # Pulls 1st item from pd.Series.
    #                         break                # Exits loop upon finding the 1st non-null animal_uid
    #     else:
    #         return None
    #
    #     if animal_uid:
    #         # The func. below with no other arguments gets the Original uid if duplicates exist, None if no duplicates.
    #         # With all_duplicates=True returns a tuple with all the UIDs of duplicates objects associated to animal_uid.
    #         # Returns None or () if no duplicates, hence the "or "
    #         dupl_uids = cls._get_duplicate_uids(animal_uid, all_duplicates=True) or (animal_uid,)
    #         uid_edr = cls._get_duplicate_uids(animal_uid) or animal_uid
    #         sql = f'SELECT * FROM "{cls.__tblObjDBName}" WHERE {getFldName(cls.tblObjName(), "fld_Duplication_Index")}'\
    #               f' IN {str(dupl_uids) if len(dupl_uids) > 1 else str(dupl_uids).replace(",", "")}; '
    #         df = pd.read_sql_query(sql, SQLiteQuery().conn)
    #         if not df.empty:
    #             # Get checksum from Earliest Duplicate Record and compare to read dataframe.
    #             # All this logic to update the memory dataframe with any new data appearing on tblOjbect.
    #             # TODO(cmt): EDR is the only record in the table with fldObjectUID = _Duplication_Index (by design)
    #             edr_idx = df[df['fld_Duplication_Index'] == uid_edr].index[df['fld_Duplication_Index'] ==
    #                                                                         df['fldObjectUID']].tolist()[0]
    #             edr_checksum = df.loc[edr_idx, 'fld_Update_Checksum']
    #             # Removes the checksum column from the checksum computation so that checksum is valid. Also sets all
    #             # null values to None BEFORE computating checksum so that it's consistent with value read from db.
    #             df.fillna(np.nan).replace([np.nan], [None], inplace=True)
    #             if edr_checksum != hashlib.sha256(df.drop('fld_Update_Checksum',axis=1).to_json().encode()).hexdigest():
    #                 # Updates empty fields in edr row with all values != None found in data frame and re-writes df to db
    #                 for name in df.columns:
    #                     if df.loc[edr_idx, name] is None:
    #                         idx = df[name].first_valid_index()
    #                         if pd.notnull(idx):           # TODO: THIS CODE IS WRONG. MUST run cls._init_uid_dicts()
    #                             df.loc[edr_idx, name] = df[name].loc[idx]
    #                 # Updates df check sum and writes edr record to db (the only record modified here).
    #                 new_checksum = hashlib.sha256(df.drop('fld_Update_Checksum', axis=1).to_json().encode()).hexdigest()
    #                 df.loc[edr_idx, 'fld_Update_Checksum'] = new_checksum
    #                 _ = setRecord(df.db.tbl_name, **df.loc[edr_idx, :].to_dict())
    #
    #             # Creates Animal object with all the data compiled in EDR (If any new data was found among duplicates).
    #             obj = cls(**df.loc[edr_idx].to_dict())
    #             if animalTags:
    #                 obj._tags_read = animalTags  # Sets up all tags scanned to id the Animal, to record inventories
    #             if load_identifiers:             # Creates BovineTag, CaprineTag objects and assigns them to obj.
    #                 identifs = obj.getIdentifiers()
    #                 if identifs:
    #                     obj.setMyTags(*[obj._myTagClass().getObject(i) for i in identifs])
    #             return obj   # Original Object uid found. cls object returned.
    #
    #     # Returning None means no duplicates for the uid (99.9% of the cases for each object table, hopefully)
    #     return None


    # @classmethod  # Implements DataFrames and non-replicated objects logic using checksums.# TODO(cmt): WORKING VERSION.
    # def getObject01(cls, obj_uid=None, *, identifier=None, load_identifiers=False):
    #     """ Returns Animal object associated to name if provided or searches by identfier. cls is Bovine, Caprine, etc.
    #     @param load_identifiers: creates Tag objects attached to object and adds them to obj attributes. Default:False.
    #     @param obj_uid: Animal UID (string).
    #     @param identifier: can be a Tag UUID or a regular human-readable string (Tag Number for Animals).
    #     Tags are normalized (removal of accents, dieresis, special characters, convert to lowercase) before processing.
    #     @return: Animal object if any found, None if none found for that obj_uid or identifier.
    #     Duplication-aware: YES
    #     """
    #     animalTags = []
    #     if obj_uid and isinstance(obj_uid, str):  # TODO: for load_identifiers use Tag.getObject()
    #         try:
    #             animal_uid = UUID(obj_uid.strip()).hex  # hex converts UUID to str.
    #         except (SyntaxError, ValueError, TypeError):
    #             return None
    #     elif identifier:  # identifier is a uid for Tag objects.
    #         if not hasattr(identifier, '__iter__'):
    #             identifier = tuple(identifier)
    #         animalTags = [cls._myTagClass().getObject(i) for i in identifier]
    #         animalTags = [t for t in animalTags if isinstance(t, Tag)]
    #         animal_uid = None
    #         # Pull animal uid from Animales table, using _identifiers_dict.
    #         for t in animalTags:
    #             animal_uid = next((k for k, v in cls.get_identifiers_dict().items() if t.ID in v), None)
    #             if animal_uid is not None:
    #                 break  # Exits loop upon finding the 1st non-null animal_uid
    #     else:
    #         return None
    #
    #     if animal_uid:
    #         # The func. below with no other arguments gets the Original uid if duplicates exist, None if no duplicates.
    #         # With all_duplicates=True returns a tuple with all the UIDs of duplicates objects associated to animal_uid.
    #         # Returns None or () if no duplicates, hence the "or "
    #         dupl_uids = cls._get_duplicate_uids(animal_uid, all_duplicates=True) or (animal_uid, '')
    #         uid_edr = cls._get_duplicate_uids(animal_uid) or animal_uid
    #         sql = f'SELECT * FROM "{cls.__tblObjDBName}" WHERE {getFldName(cls.tblObjName(), "fld_Duplication_Index")}' \
    #               f' IN {str(dupl_uids)}; '
    #         df = pd.read_sql_query(sql, SQLiteQuery().conn)
    #         if not df.empty:
    #             # Get checksum from Earliest Duplicate Record and compare to read dataframe.
    #             # TODO(cmt): EDR is the only record in the table with fldObjectUID = _Duplication_Index (by design)
    #             edr_idx = df[df['fld_Duplication_Index'] == uid_edr].index[df['fld_Duplication_Index'] ==
    #                                                                        df['fldObjectUID']].tolist()[0]
    #             edr_checksum = df.loc[edr_idx, 'fld_Update_Checksum']
    #             # Removes the checksum column from the checksum computation so that checksum is valid. Also sets all
    #             # null values to None BEFORE computating checksum so that it's consistent with value read from db.
    #             df.fillna(np.nan).replace([np.nan], [None], inplace=True)
    #             df_checksum = hashlib.sha256(df.drop('fld_Update_Checksum', axis=1).to_json().encode()).hexdigest()
    #             if edr_checksum != df_checksum:
    #                 # Updates empty fields in edr row with all values != None found in data frame and re-writes df to db
    #                 for name in df.columns:
    #                     if df.loc[edr_idx, name] is None:
    #                         idx = df[name].first_valid_index()
    #                         if idx is not None:
    #                             df.loc[edr_idx, name] = df[name].loc[idx]
    #                 # Updates df check sum and writes edr record to db (the only record modified here).
    #                 new_checksum = hashlib.sha256(df.drop('fld_Update_Checksum', axis=1).to_json().encode()).hexdigest()
    #                 df.loc[edr_idx, 'fld_Update_Checksum'] = new_checksum
    #                 _ = setRecord(df.db.tbl_name, **df.loc[edr_idx, :].to_dict())
    #
    #             # Creates Animal object with all the data compiled in EDR (If any new data was found among duplicates).
    #             dicto = df.loc[edr_idx].to_dict()
    #             obj = cls(**dicto)
    #             if animalTags:
    #                 obj._tags_read = animalTags  # Sets up all tags scanned to id the Animal, to record inventories
    #             if load_identifiers:  # Creates BovineTag, CaprineTag objects and assigns them to obj.
    #                 identifs = obj.getIdentifiers()
    #                 if identifs:
    #                     obj.setMyTags(*[obj._myTagClass().getObject(i) for i in identifs])
    #             return obj  # Original Object uid found. cls object returned.
    #
    #     # Returning None means no duplicates for the uid (99.9% of the cases for each object table, hopefully)
    #     return None


    @staticmethod
    def getClassesEnabled():
        return Animal.__classesEnabled

    @staticmethod
    def getAnimalModeDict():
        return Animal.__animalMode

    # GENERAL Set with all progActivities currently assigned to at least 1 animal in registerDict. For ease of search.
    # TODO(cmt): MUST be a list, as repeated objects must be managed. This is a collection of ALL the items
    #  in __myProgActivities for ALL objects defined. Don't have a use for it yet...
    __activeProgActivities = list()

    # All tags assigned to this class (Animal in this case

    @classmethod
    def getAllAssignedTags(cls):            # TODO: must be implemented in all subclasses (Bovine, Caprine, etc.)
        return {}

    @classmethod
    def activeProgActivities(cls):
        return cls.__activeProgActivities

    # {Animal Kind: ID_Clase De Animal, }, ej: {'Vacuno': 1, 'Caprino': 2, }

    tempdf = getrecords('tblAnimalesClases', 'fldID', 'fldAnimalClass')
    __animalKinds = dict(zip(tempdf['fldAnimalClass'], tempdf['fldID']))    # {Clase De Animal (str): animalClassID}
    del tempdf

    @staticmethod
    def getAnimalKinds():
        return Animal.__animalKinds  # {'Bovine': 1, 'Caprine':2, 'Ovine':3, etc } -> leido de DB.

    @classmethod
    def get_mf_from_cat(cls, category):
       pass


    # @classmethod
    # def getRegisterDict(cls):  # TODO: implemented in Animal subclasses (Bovine, Caprine, etc.). DEPRECATED 10-Dec-23!!
    #     return {}


    # Dictionary with kinds of animals actually in use (only animal kinds for modules loaded: Bovine, Caprine, etc).
    # Populated during initialization of Animal Classes (Bovine, Caprine, etc),.
    # TODO(cmt): When a module shuts down the cleanup code MUST remove its Class (cls) from __registeredClasses.
    #  Entries and removals done from child classes (Bovine, Caprine, etc)
    __registeredClasses = {}    # {cls: kindOfAnimalID} -> {Bovine: 1, Caprine: 2, Ovine: 3, } Bovine is a class.
    __tagClasses = {}            # {cls: tagClass} -> {Bovine: TagBovine, Caprine:TagCaprine, }


    @classmethod
    def getAnimalClasses(cls):
        return cls.__registeredClasses  # {cls: kindOfAnimalID}

    @classmethod
    def removeAnimalClass(cls):
        """ Removes entry from __registeredClasses.
        @return: cls or None if cls does not exist in dictionary """
        cls.__registeredClasses.pop(cls, None)
        cls.__tagClasses.pop(cls, None)

    @classmethod
    def getAnimalClassName(cls):        # animalKind: 'Vacuno', 'Ovino', 'Caprino', etc.
        """ Returns cls.__name__ corresponding to animalKind.
        @return: Animal Class Name ('Bovine', 'Caprine', etc). None if animalKind is not valid
        """
        return cls.__name__   # if cls.__name__ in Animal.getAnimalClasses() else None

    @classmethod
    def getAnimalClassID(cls):
        return cls._kindOfAnimalID              # Gets the right _kindOfAnimalID from subclasses.

    @classmethod
    def classID(cls):
        """
        @return:  Returns animalClassID (int)
        """
        return cls._kindOfAnimalID              # Gets the right _kindOfAnimalID from subclasses.

    @classmethod
    def className(cls):
        """
        @return:  Returns animalKind (str): 'Vacuno', 'Caprino', etc.
        """
        return cls._animalClassName             # Gets the right _animalClassName from subclasses.

    @classmethod
    def registerTagClass(cls):              # {animalClass: tagClass, }  ---> {Bovine, TagBovine, }
        cls.__tagClasses[cls] = next((k for k, v in Tag.getTagClasses().items() if v == cls._kindOfAnimalID), None)

    @classmethod
    def getTagClasses(cls):
        """Returns dictionary of tag classes. Used to select a Tag class associated with the Animal class
        @return: {AnimalClass: TagClass, }
        """
        return cls.__tagClasses

    @classmethod
    def create_tag_identifier(cls, number: str = None):
        """ Creates a tag identifier of the form "number-assignedToClass". Example: 2845-Bovine, A98x-Caprine. """
        if isinstance(number, str):
            return Tag.create_identifier(elements=(number.strip(), Tag._tagIdentifierChar, cls.__name__))
        return None


    @classmethod
    def _myTagClass(cls):
        """Returns the Tag class associated with the Animal class (TagStandardBovine, TagRFIDCaprine, etc.)
        @return: Tag subclass
        """
        return getattr(cls, 'Tag' + cls.__name__)  # returns <TagBovine>, <TagCaprine> if they exit. Or raise AttrError.


    @classmethod
    def createTagSubClass(cls):
        """Returns a sub class of Tag, specific for this class of Animal. """
        tag_class_name = 'Tag' + cls.__name__
        setattr(cls, tag_class_name, cls._tagCreatorClass()._create_subclass(tag_class_name, obj_class=cls))


    tempdf = getrecords('tblAnimalesActividadesNombres', 'fldID', 'fldName', 'fldFlag', 'fldFK_ClaseDeAnimal')
    __activitiesForMyClass = {}
    for j in tempdf.index:
        __activitiesForMyClass[tempdf.loc[j, 'fldName']] = tempdf.loc[j, 'fldFlag']  # {Nombre Actividad: AnimalClass, }
    del tempdf

    __tblDataInventoryName = 'tblDataAnimalesActividadInventario'
    __tblDataStatusName = 'tblDataAnimalesActividadStatus'
    __tblClassName = 'tblAnimalesClases'
    __tblDataCategoriesName = 'tblDataAnimalesCategorias'
    __tblRAName = 'tblAnimalesRegistroDeActividades'
    __tblLinkName = 'tblLinkAnimalesActividades'
    __tblDataLocalizationName = 'tblDataAnimalesActividadLocalizacion'
    __paClass = ProgActivityAnimal
    __tblLinkPAName = 'tblLinkAnimalesActividadesProgramadas'       # Usado en object_instantiation.loadItemsFromDB()
    __tblRAPName = 'tblAnimalesRegistroDeActividadesProgramadas'

    @classmethod
    def getPAClass(cls):
        return cls.__paClass


    #  "42990b601cec4ddb9d85bfb94cda2e29" : El Nandu - Lote 1

    @classmethod
    def tblRAName(cls):
        return cls.__tblRAName

    @classmethod
    def tblLinkName(cls):
        return cls.__tblLinkName

    @classmethod
    def tblRAPName(cls):
        return cls.__tblRAPName

    @classmethod
    def tblLinkPAName(cls):
        return cls.__tblLinkPAName


    def __new__(cls, *args, **kwargs):          # __new__() override prevents instantiation of Animal class.
        if cls is Animal:
            krnl_logger.error(f"ERR_SYS_Invalid type: {cls.__name__} cannot be instantiated, please use a subclass")
            raise TypeError(f"{cls.__name__} cannot be instantiated, please use a subclass")
        return super().__new__(cls)

    def __init__(self, *args, **kwargs):
        self.__myTags = set()
        self._fldDOB = kwargs.get('fldDOB', None)        # dob is None for Animal classes that don't required  DOB.
        myID = kwargs.get('fldObjectUID', None)
        self.__recordID = kwargs.get('fldID', None)
        try:
            _ = UUID(myID)
        except(TypeError, ValueError):
            del self
            raise ValueError(f'ERR_INP: invalid/malformed UUID {myID}. Animal object cannot be created.')

        if kwargs.get('fldMF', '').lower() not in ('m', 'f') or not kwargs.get('fldFK_ClaseDeAnimal'):
            # del self
            raise TypeError('ERR_INP_Invalid or missing M/F status and/or Animal class . Animal object not created!')

        # self._ageDaysDeviation = kwargs.get('fldAgeDaysDeviation', 0)       # What is this needed for??
        self._fldMF = kwargs.get('fldMF').lower()
        self._timeStamp = kwargs.get('fldTimeStamp', None)    # Esta fecha se usa para gestionar objetos repetidos.
        self._fldFlagCastrado = kwargs.get('fldFlagCastrado') if kwargs.get('fldFlagCastrado') else 0
        if isinstance(self._fldFlagCastrado, datetime):
            self._fldFlagCastrado = self._fldFlagCastrado.timestamp()
        animalClassID = next((kwargs[j] for j in kwargs if 'animalclass' in j.lower() or 'clasedeanim' in j.lower())
                             , None)
        self._kindOfAnimalID = animalClassID if animalClassID in list(self.__animalKinds.values()) else None
        self._animalClassName = next(j for j in self.__animalKinds if self.__animalKinds[j] == self._kindOfAnimalID)
        self._fldFK_Raza = kwargs.get('fldFK_Raza')
        # fldDate (Fecha Evento) de tblAnimales. Se usa en manejo de Dummy Animals en altaMultiple(), perform()

        isValid = True
        isActive = True
        self._mode = kwargs.get('fldMode', '').lower()
        try:
            self._mode = self._mode.lower() if self._mode.lower() in self.__animalMode else 'regular'
            # countMe: Flag 1 / 0 para indicar si objeto se debe contar o no.
            #  1: Regular Animal;
            #  0: Substitute (Animal creado por Reemision de Caravana); External Animal; Generic Animal
            # -1: Dummy (Creado por perform de un Animal Substitute)
            self.__countMe = Animal.__animalMode[self._mode]
        except AttributeError:
            self._mode = None       # _mode is None for Animal classes that don't implement the mode attribute.
            self.__countMe = 1      # __countMe is always one if mode is not implemented.

        # list of progActivities active for object. Loaded from DB and then updated by the system.
        # TODO(cmt): Each node initializes and loads ONLY ProgActivities created by this node in __myProgActivities.
        #  This is to implement a consistent ProgActivity closure across all nodes when all db records are replicated.
        self.__myProgActivities = {}  # Dict {paObj: __activityID}

        # TODO: inputs de name desde la UI se deben procesar con removeAccents() para comparar con obj._name
        self._name = removeAccents(kwargs.get('fldName', ''))
        self._conceptionType = kwargs.get('fldConceptionType', 'natural') \
            if kwargs.get('fldConceptionType', 'natural').lower() in self.__conceptionTypes else 'natural'
        self.__surrogateMother = kwargs.get('fldFK_MadreSubrogante', None)
        self.__comment = kwargs.get('fldComment', '')
        self.__exitDate = kwargs.get('fldDateExit') or 0           # DBKeyName: fldDateExit
        if isinstance(self.__exitDate, datetime):
            self.__exitDate = int(self.__exitDate.timestamp())
        if self.__exitDate:                                    # TODO(cmt): exitDate puede ser: 0, 1, datetime Object.
            isActive = False

        self.__identifiers = kwargs.get('fldIdentificadores') or set()      # set of Tag UIDs for Animals.
        if self.__identifiers:
            self.__identifiers = set(self.__identifiers)        # turns list read from DB into set().
            # print(f'self.__identifiers: {self.__identifiers}', dismiss_print=DISMISS_PRINT)

        # List of tags scanned for Animal in any Activity. Used in tbl DataAnimalesCaravanas for PHATT management logic.
        # Made thread-safe for future extensions: every object gets a dict with tags read, on a per-thread basis.
        self._tags_read = collections.defaultdict(list)   # {thread_id: tagObj_list, }
        # t0 used to simulate DOB, inventory dates when USE_DAYS_MULT is in use.
        self.t0 = (time_mt() - (randint(0, 15)+random())) if USE_DAYS_MULT else 0  # random of 0 - 3 years for DAYS_MULT = 60

        super().__init__(myID, isValid, isActive, *args, **kwargs)   # Llama a Asset.__init__()

    # ---------------------------------------Fin __init__() ---------------------------------------------------- #

    def __repr__(self):                 # self.getCategories() gets the right __categories dictionary.
        try:
            return "[({}); Tags:{}; uid:{}]".format(self.recordID, str(self.myTagNumbers)[1:-1], self.ID)
        except (KeyError, IndexError, Exception):
            return "[Tags:{}; Age:{:1}]".format(str(self.myTagNumbers)[1:(-2 if len(self.myTagNumbers) == 1 else -1)],
                                                int(self._age()))

        # return "[{} ({}); Tags:{}; uid:{}]".format(self.category.get(id_type='name'), self.recordID,  #
        #                                            str(self.myTagNumbers)[1:-1], self.ID)

    @property
    def tags_read(self):
        return self._tags_read[threading.current_thread().ident]        # returns a set of tag objects.

    @tags_read.setter
    def tags_read(self, tag_list):
        if isinstance(tag_list, (list, set, tuple)):
            tag_list = list(tag_list)
        elif isinstance(tag_list, Tag):
            tag_list = [tag_list, ]
        else:
            return      # Invalid data: quits without updating _tags_read attribute.
        self._tags_read[threading.current_thread().ident] = tag_list     # list of tag objects read for self obj.

    def updateAttributes(self, **kwargs):
        """ Updates object attributes with values passed in attr_dict. Values not passed leave that attribute unchanged.
        @return: None
        """
        if not kwargs:
            return None

        self._fldDOB = kwargs.get('fldDOB') or self._fldDOB
        self._fldMF = kwargs.get('fldMF').lower() or self._fldMF
        # self._fldTimeStamp = kwargs.get('fldTimeStamp')           # Este campo no se debe actualizar
        self._fldFlagCastrado = int(kwargs.get('fldFlagCastrado')) if kwargs.get('fldFlagCastrado') is not None else \
            self._fldFlagCastrado
        # animalClassID = next((kwargs[j] for j in kwargs if 'animalclass' in j.lower() or 'clasedeanim' in j.lower())
        #                      , None)
        # self._kindOfAnimalID = animalClassID if animalClassID in list(self.__animalKinds.values()) else None
        # self._animalClassName = next(j for j in self.__animalKinds if self.__animalKinds[j] == self._kindOfAnimalID)
        self._fldFK_Raza = kwargs.get('fldFK_Raza') or self._fldFK_Raza
        # isValid = True
        # isActive = True

        self._mode = kwargs.get('fldMode') or self._mode
        self._mode = self._mode if self._mode in self.__animalMode else 'regular'
        # countMe: Flag 1 / 0 para indicar si objeto se debe contar o no.
        #  1: Regular Animal;
        #  0: Substitute (Animal creado por Reemision de Caravana); External Animal; Generic Animal
        # -1: Dummy (Creado por perform de un Animal Substitute)
        self.__countMe = Animal.__animalMode[self._mode]

        # list of progActivities active for object. Loaded from DB and then updated by the system.
        # self.__myProgActivities = kwargs.get('fldProgActivities', {})  # Dict {paObj: __activityID}

        # TODO: inputs de name desde la UI se deben procesar con removeAccents() para comparar con obj._name
        self._name = removeAccents(kwargs.get('fldName', None)) or self._name
        self._conceptionType = kwargs.get('fldConceptionType', None) if kwargs.get('fldConceptionType', '').lower() \
                                                                in self.__conceptionTypes else self._conceptionType
        self.__surrogateMother = kwargs.get('fldFK_MadreSubrogante', None) or self.__surrogateMother
        self.__comment = kwargs.get('fldComment', '') or self.__comment

        # self.__exitDate = kwargs.get('fldDateExit') or 0  # DBKeyName: fldDateExit

        self.__identifiers = kwargs.get('fldIdentificadores') or self.__identifiers
        if self.__identifiers:
            self.popMyTags('*')
            self.setMyTags(*[Tag.getObject(uid) for uid in self.__identifiers])

        return None

    def categoryName(self):
        """ Returns category Name corresponding to self.lastCategoryID or None if category not defined.
        """                     # self.getCategories() pulls the right __categories dictionary.
        return next((k for k in self.getCategories() if self.getCategories()[k] == self.lastCategoryID), 'No Category.')


    @property
    def name(self):
        return self._name or str(tuple(self.myTagNumbers)).replace("(", "").replace(")", "")


    @classmethod
    def getCount(cls, mode=1, *, fetch_from_db=False):
        """
        Counts total animals for given Animal Class.

        @param mode: 0: ALL ID_Animal in cls.__registerDict for given class.
                     1 (Default): Only ACTIVE Animals. Useful to count stocks.
         @param fetch_from_db: True: Reads data from database (Animales tbl). False: Uses memory dataframe. Default: False.
        @return: Animal count for class cls (int)
        Duplication-aware: Must count only 1 instance of records that share the same _Duplication_Index value.
        Duplication-aware: YES
        """
        sql = f'SELECT * FROM "{cls.tblObjDBName()}" '
        if mode:
            sql += f'WHERE "{getFldName(cls.tblObjName(), "fldDateExit")}" == 0 ' \
                   f'OR "{getFldName(cls.tblObjName(), "fldDateExit")}" IS NULL; '
        else:
            sql += '; '
            fetch_from_db = True        # Forces retrieval from db to get Active and Inactive animals.

        if fetch_from_db:
            itr = pd.read_sql_query(sql, SQLiteQuery().conn, chunksize=PANDAS_READ_CHUNK_SIZE)
        else:
            itr = cls.obj_dataframe()        # From memory: only active Animals.

        return cls.processCount(itr)


    # @classmethod
    # def getTotalCount00(cls, mode=1):
    #     """
    #     Counts total animals for given Animal Class.
    #     @param mode: 0: ALL ID_Animal in cls.__registerDict for given class.
    #         `        1 (Default): Only ACTIVE Animals. Useful to count stocks.
    #     @return: Animal count for class cls (int)
    #     Duplication-aware: Must count only 1 instance of records that share the same _Duplication_Index value.
    #     Duplication-aware: YES
    #     """
    #     sql = f'SELECT * FROM "{cls.tblObjDBName()}" '
    #     if not mode:
    #         sql += '; '
    #     else:
    #         sql += f' WHERE {getFldName(cls.tblObjName(), "fldDateExit")} == 0 OR ' \
    #                f'{getFldName(cls.tblObjName(), "fldDateExit")} IS NOT NULL; '
    #     tbl = dbRead(cls.tblObjName(), sql)  # fldObjectUID is a unique value->Only 1 record returned (or None)
    #     if not isinstance(tbl, DataTable) or not tbl:
    #         return None
    #     return cls.processCount(tbl)

    sqlAnimales = 'SELECT * From Animales WHERE "Salida YN" == 0 OR "Salida YN" IS NULL; ' # TODO: Leave for reference.


    @classmethod
    def processCount(cls, frames):      # Dataframe or iterable.
        """
        Returns the total number of unique items found in frames, processed for record duplication.
        This method is intended to provide flexibility in object counting, taking a filtered DataFrame as argument.
        @param frames: DataFrame or Iterator with filters applied.
        @return: Total count of unique items in tbl (int). None if frames is not of a valid type.
        Duplication-aware: YES
        """
        if isinstance(frames, pd.DataFrame):
            frames = iter((frames, ))
        if pd.api.types.is_iterator(frames):
            count = 0
            # 1. Adds up duplicated records.
            for df in frames:
                ser = df.groupby('fld_Duplication_Index')['fldMode'].agg(set)
                if len(ser.index):
                    count += cls.__animalMode.get(ser[0].pop(), 0)
                # groups = df.groupby('fld_Duplication_Index')     # 1 group of records for each fld_Duplication_Index.
                # for name, frame in groups:
                #     count_val = cls.__animalMode.get(frame.loc[0, 'fldMode'], 0)  # Uses 1st row to pull fldMode value
                #     count += count_val

                # 2. Adds up non-duplicated records.
                no_duplicates = df[df['fld_Duplication_Index'].isnull()]['fldMode']     # pd.Series
                count += no_duplicates.apply(cls.__animalMode.get).sum()
            return count
        else:
            return None


    # @classmethod
    # def processCount00(cls, tbl: DataTable):
    #     """
    #     Returns the total number of unique items found in tbl, already processed for record duplication.
    #     Processes the count of items passed on a filtered DataTable, taking into account the Duplication of records in
    #     tblAnimales.
    #     This method is intended to provide flexibility in object counting taking a filtered DataTable as argument.
    #     @param tbl: dataTable with filters applied.
    #     @return: Total count of unique items in tbl (int).
    #     Duplication-aware: YES
    #     """
    #     if isinstance(tbl, DataTable) and tbl and all(f in tbl.fldNames for f in ('fldMode', 'fld_Duplication_Index')):
    #         idx_mode = tbl.getFldIndex('fldMode')
    #         idx_dupl = tbl.getFldIndex('fld_Duplication_Index')
    #         # pairs = {modeCounter, _Duplication_Index}
    #         # Remove repeat (counter, _Duplication_Index) pairs. Leave only one per _Duplicat_Index using set()
    #         pairs = set([(cls.__animalMode.get(j[idx_mode].lower(), 0), j[idx_dupl]) for j in tbl.dataList])
    #         return sum([p[0] for p in pairs])
    #     else:
    #         return None

    # def setIdentifier(self, identifier):        # TODO: Not valid for Animales. Use assignTags()
    #     """ Animal identifier. Adds an identifier to the __identifiers set, and updates Animales db table.
    #     Three data structures to update:
    #     1. Object (self.__identifiers)
    #     2. Database record (fldIdentificadores in tblObject()).
    #     3. __identifiers dict (if defined for the class).
    #     In the case of Animals as this one, Identifier must be a valid UUID or a string that converts to UUID.
    #     @return: New identifier for object (set)."""
    #     ident = None
    #     if isinstance(identifier, UUID):
    #         ident = identifier.hex
    #     elif isinstance(identifier, str):
    #         try:
    #             ident = UUID(identifier).hex
    #         except (SyntaxError, TypeError, ValueError):
    #             return None
    #     if ident:
    #         self.__identifiers.add(ident)     # All Animal identifiers are str. __identifiers is a set for Animal class.
    #         _ = setRecord(self.tblObjName(), fldID=self.recordID, fldIdentificadores=self.__identifiers)
    #         # Updates _identifiers (if they exist) for self. To do this, must load the full table back into memory.
    #         # (A consequence of working with iterators in obj_dataframe()).
    #         self._init_uid_dicts()
    #
    #     return self.__identifiers


    # def removeIdentifier(self, ident=None):     # TODO: Not valid for Animales. Use deassignTags()
    #     """ Three data structures to update:
    #     1. Object (self.__identifiers)
    #     2. Database record (fldIdentificadores in tblObject()).
    #      3. __identifiers dict (if defined for the class).
    #     @param ident: Identifier to remove from set.
    #     @return: True if removed. None if not found/not removed.
    #     """
    #     if ident in self.__identifiers:     # self.__identifiers is a set() for Animals.
    #         self.__identifiers.discard(ident)
    #         _ = setRecord(self.tblObjName(), fldID=self.recordID, fldIdentificadores=self.__identifiers)
    #         self._init_uid_dicts()      # Reloads all data from memory.
    #         return ident
    #     return None


    @classmethod
    def GenActivity_register_func(cls, *, property_name: str = None, func_object=None):
        """
        Registers a function as an attribute (method) of the Generic Activity object pointed to by property name.
        *** The registered method must be an attribute of the instance, NOT the GenericActivity class. ***
        Uses fget() to access the underlying object of the property, as the property is the only handle available.
        @param property_name: property (decorator) name
        @param func_object: method or function object to register for object attached to property_name.
        @return: None
        """
        if not isinstance(property_name, str) or not callable(func_object):
            return None
        try:
            # Pulls the object associated with property_name. by using fget (no parenthesis), the object is returned
            # WITHOUT invoking the object's __call__ method, which in this case is unnecessary.
            # fget() also could be used only because calling fget() returns the same object type as is stored by fget.
            activity_obj = getattr(cls, property_name).fget
        except (AttributeError, NameError):
            activity_obj = None
        if activity_obj:
            activity_obj.register_method(method_obj=func_object)
        return None


    @classmethod
    def initialize(cls):
        """ ActivityMethod for initialization of animals upon loading records from DB"""
        pass

    @property
    def recordID(self):
        return self.__recordID


    @property
    def mode(self):
        return self._mode

    @mode.setter
    def mode(self, val):
        if val in set(Animal.__animalMode.keys()):
            self._mode = val

    @property
    def countMe(self):
        return self.__countMe

    @countMe.setter
    def countMe(self, val):
        self.__countMe = val if val in set(Animal.__animalMode.values()) else 0


    def getIdentifiers(self):
        """Returns Animal identifiers (uid strings). They are Tag uids. """
        return tuple(self.__identifiers)     # Returns a list of identifiers (Tag uids), tupled so that can index it.

    @classmethod
    def get_identifiers(cls, uid):
        """ Returns identifiers read associated to uid. None if uid not found.
        Used by classes to pull identifiers for an object without having to create the object via getObject(). """
        with cls._sem_obj_dataframe:      # Will enter a wait if obj_dataframe is being updated by other threads.
            for frame in cls.obj_dataframe():
                identifs = frame.loc[frame['fldObjectUID'] == uid, 'fldIdentificadores']        # pd.Series
                if len(identifs.index):
                    return tuple(identifs[0])    # This should be a list of Identifier (Tags) uids.


    @property
    def isRegular(self):
        """
        Regular are physical animals defined in the system
        @return: True / False
        """
        return 'regular' in self._mode.lower()               # TODO: AQUI ESTA LA MERMA CON LOS THREADS!!! Cual seria??

    @property
    def isDummy(self):
        """
        Returns ID_Dummy condition. Dummy IDs are ID_Animal with countMe=-1 to support the logic handling Animals with
        missing or no assigned Tags.
        @return: True / False
        """
        return 'dummy' in self._mode.lower()

    @property
    def isSubstitute(self):
        """
        Returns Substitute condition. Substitute IDs are ID_Animal with countMe=0 to support the logic handling Animals
        with missing or no assigned Tags.
        @return: True / False
        """
        return 'substit' in self._mode.lower()


    @property
    def isExternal(self):
        """
        Returns External condition. External means Animal not in control of this system. Animal is externally owned and
        externally managed. Example: Father/Mother of an animal defined in the system that is not part of this system.
        @return: True / False
        """
        return 'extern' in self._mode.lower()

    @property
    def isGeneric(self):
        """
        Returns Generic Animal condition. Generics have countMe=0 to support the logic for multiple-animal notifications
        and Programmed Activities.
        @return: True / False
        """
        return 'generic' in self._mode.lower()

    @property
    def tblDataInventoryName(self):
        return self.__tblDataInventoryName

    @property
    def tblObjectsName(self):
        return self.__tblObjName

    @property
    def tblDataStatusName(self):
        return self.__tblDataStatusName

    # Diccionario Animal.Status - UNICO DICCIONARIO CON VALUES=[list]. Los demas dicts se deberan crear con val unico
    tempdf = getrecords('tblAnimalesStatus', 'fldID', 'fldStatus', 'fldFlag')
    __animalStatusDict = {}
    Status = collections.namedtuple("Status", ('status_id', 'active'))
    for j, row in tempdf.iterrows():                # {statusName: [statusID, activeYN]}
        __animalStatusDict[str(row['fldStatus'])] = Status(int(row['fldID']), int(row['fldFlag']))

    @property
    def statusDict(self):  # Diccionario con definicion de Animal Status
        return self.__animalStatusDict

    @classmethod
    def getStatusDict(cls):
        return cls.__animalStatusDict


    @classmethod
    def generateDOB(cls, categoryArg, startDate=None):
        """
        Creates a DOB based on Animal Class and CategoryActivity. Used to provide a DOB when one is not passed via UI.
        Any DOB that comes from UI overrides the system generated DOB.
        @param categoryArg: Animal category (str). Mandatory.
        @param startDate: Initial date to create a dob from. It's a datetime object. Default: None converts to now().
        DOB is counted backward from this startDate, a number of days determined by Category.
        @return: datetime DOB or errorCode (str)
        """
        ageLimitsDict = cls._myActivityClass.getAgeLimits()    # cls resolves the correct AgeLimits dict to retrieve.
        if categoryArg not in ageLimitsDict:
            raise ValueError(f'ERR_INP_InvalidArgument: {categoryArg} - {moduleName()}({lineNum()}) - {callerFunction()}')
        age = ageLimitsDict[categoryArg]
        eventDate = time_mt('dt')
        if age > 0:
            startDate = startDate if isinstance(startDate, datetime) else eventDate
            if USE_DAYS_MULT:
                if (eventDate - startDate).total_seconds() * DAYS_MULT > cls.__MIN_REWIND_DAYS:
                    raise ValueError(f'ERR_INP_InvalidArgument: {startDate} out of range - '
                                     f'{moduleName()}({lineNum()}) - {callerFunction()}')
            else:
                if eventDate - dt.timedelta(days=cls.__MIN_REWIND_DAYS) >= startDate:
                    raise ValueError(f'ERR_INP_InvalidArgument: {startDate} out of range - '
                                     f'{moduleName()}({lineNum()}) - {callerFunction()}')

            dobSys = startDate - dt.timedelta(days=age)
            dobSys = dobSys.replace(hour=22, minute=22, second=22, microsecond=222222)  # Mask for System-set DOB
            retValue = dobSys
        else:
            raise ValueError(f'ERR_INP_InvalidArgument: {categoryArg} - {moduleName()}({lineNum()})-{callerFunction()}.'
                             f'\nDOB not created. Cannot instantiate animal object.')
        return retValue

    @property
    def dob(self):
        """
        returns DOB as a datetime object
        @return: datetime object date of birth.
        """
        return self._fldDOB

    @dob.setter
    def dob(self, val):
        """
        sets dob as a datetime object
        @param val: dob (datetime object)
        @return:
        """
        if isinstance(val, datetime):
            self._fldDOB = val


    class DOB:                  # Little test for DOB to manage computed-by-system and user-entered dob values.
        def __init__(self, dob=None, *, computed=False):
            self.__dob = dob
            self.__computed = computed

        def __repr__(self):
            return self.__dob

        @property
        def dob(self):
            return self.__dob

        @dob.setter
        def dob(self, val):
            self.__dob = val

        @property
        def computed(self):
            return self.__computed

        @computed.setter
        def computed(self, val):
            self.__computed = val



    def _age(self, *, computing_date=False, time_delta=False):
        """
        Returns age (if DOB is defined for the object) as days (default). age_timedelta=True -> datetime.timedelta.
        @param age_delta: True: returns datetime.delta object. False (default): Age in days.
        @return: Age: age in number of days since dob (float) or delta object.
        """
        if time_delta:
            return time_mt('datetime') - self.dob        # returns timedelta structure (years, months, days, min, sec)
        elif computing_date:
            return time_mt('datetime')      # Retorna fecha en que se computa la edad.
        else:
            return (time_mt()-self.t0) * DAYS_MULT if USE_DAYS_MULT else (time_mt('datetime') - self.dob).days


    @property
    def mf(self):
        return self._fldMF

    def _set_mf(self, val):
        if isinstance(val, str):
            val = val.strip().lower()
            if val in ('m', 'f'):
                self._fldMF = val

    @property
    def isCastrated(self):
        return self._fldFlagCastrado

    @isCastrated.setter
    def isCastrated(self, val):
        self._fldFlagCastrado = bool(val)       # val if isinstance(val, datetime) else bool(val)

    @property
    def animalClass(self):
        """
        @return:  Returns animalClassID: Vacuno, Ovino, etc. (string). DEPRECATED, left here for compatibility for now.
        """
        return self._kindOfAnimalID

    @property
    def animalClassID(self):
        """
        @return:  Returns animalClassID (int)
        """
        return self._kindOfAnimalID

    @property
    def animalClassName(self):
        """
        @return:  Returns animalClass Name (str)
        """
        return self._animalClassName

    @property
    def animalRace(self):
        return self._fldFK_Raza

    @property
    def exitYN(self):
        return self.__exitDate

    def setExitDate(self, val):
        self.__exitDate = val if isinstance(val, datetime) else bool(val) * 1

    @property
    def myTimeStamp(self):   # unusual name to avoid conflicts with the many date, timeStamp, fldDate in the code.
        """
        @return: record creation timestamp as a datetime object.
        """
        return self._timeStamp

    # @fldDate.setter
    # def fldDate(self, val):
    #     """
    #     sets fldDate as a datetime object
    #     @param val: fldDate (datetime object)
    #     @return:
    #     """
    #     if isinstance(val, datetime):
    #         self._timeStamp = val
    #     else:
    #         try:
    #             self._timeStamp = strptime(val, fDateTime)
    #         except (TypeError, ValueError):
    #             raise TypeError(f'ERR_Invalid type for datetime value.')

    @property
    def myProgActivities(self):
        """ Returns dict of ProgActivities assigned to object """
        return self.__myProgActivities          # Dict {paObject: __activityID}

    def registerProgActivity(self, obj: ProgActivity):
        # TODO(cmt): Each node initializes and loads in __myProgActivities ONLY ProgActivities created by itself.
        #  This is to implement a consistent ProgActivity closure across all nodes when all db records are replicated.
        if isinstance(obj, ProgActivity) and obj.isActive > 0 and obj.dbID == TERMINAL_ID:
            if obj not in self.__myProgActivities:
                self.__myProgActivities[obj] = obj.activityID        # Dict {paObject: __activityID}
                self.__activeProgActivities.append(obj)              # set {paObj, }. ALWAYS appends for this to work.

    def unregisterProgActivity(self, obj: ProgActivity):
        if isinstance(obj, ProgActivity) and obj in self.__myProgActivities:   #  and obj.isActive < 2:
            self.__myProgActivities.pop(obj, None)                   # Dict {paObject: __activityID, }
            try:
                return self.__activeProgActivities.remove(obj)       # List [paObj, ].  Must remove().
            except ValueError:
                return None

    @classmethod
    def paCreateActivity(cls, activity_id=None, *args: DataTable, enable_activity=activityEnableFull, items_dict=None,
                         **kwargs):
        """ Creates a Animal Programmed Activity (PA) and registers the created object in __registerDict.
        Records data in the RAP, Data Programacion, tblLinkPA in database.
        @param enable_activity:
        @param activity_id: (int). Activity ID defined in cls.supportsPA dict.
        @param items_dict: dict {objID: fldProgrammedDate} for objects that the progActivity is to be assigned to.
        @param args: tblLinkPA must be fully populated with items and fldProgrammedDate fields.
        @param kwargs: data fields for progActivity. See _paCreateActivity() definition in abstract_class_prog_activity.py.
        @return: ProgActivity Object. ERR_ (str) if class is not valid or if recordActivity() finished with errors.

        """
        paClass = cls.getPAClass()
        if activity_id not in paClass.progActivitiesDict().values():   # This is a definitions dict.
            return f'ERR_INP_InvaLid Argument(s) {activity_id}'  # Actividad no definida o no valida para progActivity.

        # tblLinkPA = next((j for j in args if isinstance(j, DataTable) and j.tblName == cls.tblLinkPAName()),
        #                  DataTable(cls.tblLinkPAName()))
        dfLinkPA = next((j for j in args if isinstance(j, pd.DataFrame) and j.db.tbl_name == cls.tblLinkPAName()),
                         pd.DataFrame.db.create(cls.tblLinkPAName()))

        # 1. Crea Actividad. paClass es ProgActivityAnimal.
        paObj = paClass._paCreateActivity(activity_id, *args, enable_activity=enable_activity, **kwargs)
        itemsDict = items_dict if isinstance(items_dict, dict) else {}
        if dfLinkPA.empty:
            # Si no se pasa tblLinkPA con datos, toma obj: fldProgrammedDate de itemsDict y Valida elementos.
            itemsDict = {k: v for (k, v) in itemsDict.items() if k in cls.get_active_uids_iter() and
                         isinstance(v, datetime)}
        if isinstance(paObj, paClass) and itemsDict:
            # 2. Create records en tblLinkPA. fldProgrammedDate MUST be supplied in args DataTable.
            for j, k in enumerate(itemsDict):
                # Creates execution instance for object k
                dfLinkPA.loc[j, ('fldFK_Actividad', 'fldFK', 'fldProgrammedDate', 'fldComment')] = \
                    (paObj.ID, k.ID, itemsDict[k], f'Object: {k} / Activity: {activity_id}.')

            _ = setrecords(dfLinkPA)          # Crea los records en tblLinkPA

            # # 3. Registra progActivity creada con cada uno de los objetos (Bovine, etc.) para los que fue definida
            # objList = [o for o in cls.getRegisterDict().values() if o.isActive and o.ID in itemsDict.keys()]
            # if objList:
            #     for o in objList:
            #         o.registerProgActivity(paObj)    # myProgActivities = {paObj: __activityID}
            #     return objList

            return paObj
        return None



    # @classmethod                    # DEPRECATED. USES DataTable.
    # def paCreateActivity00(cls, activity_id=None, *args: DataTable, enable_activity=activityEnableFull, items_dict=None,
    #                      **kwargs):
    #     """ Creates a Animal Programmed Activity (PA) and registers the created object in __registerDict.
    #     Records data in the RAP, Data Programacion, tblLinkPA in database.
    #     @param enable_activity:
    #     @param activity_id: (int). Activity ID defined in cls.supportsPA dict.
    #     @param items_dict: dict {objID: fldProgrammedDate} for objects that the progActivity is to be assigned to.
    #     @param args: tblLinkPA must be fully populated with items and fldProgrammedDate fields.
    #     @param kwargs: data fields for progActivity. See _paCreateActivity() definition in abstract_class_prog_activity.py.
    #     @return: ProgActivity Object. ERR_ (str) if class is not valid or if recordActivity() finished with errors.
    #
    #     """
    #     paClass = cls.getPAClass()
    #     if activity_id not in paClass.progActivitiesDict().values():  # This is a definitions dict.
    #         return f'ERR_INP_InvaLid Argument(s) {activity_id}'  # Actividad no definida o no valida para progActivity.
    #
    #     tblLinkPA = next((j for j in args if isinstance(j, DataTable) and j.tblName == cls.tblLinkPAName()),
    #                      DataTable(cls.tblLinkPAName()))
    #     dfLink = next((j for j in args if isinstance(j, pd.DataFrame) and j.db.tbl_name == cls.tblLinkPAName()),
    #                   pd.DataFrame.db.create(cls.tblLinkPAName()))
    #
    #     # 1. Crea Actividad. paClass es ProgActivityAnimal.
    #     paObj = paClass._paCreateActivity(activity_id, *args, enable_activity=enable_activity, **kwargs)
    #     itemsDict = items_dict if isinstance(items_dict, dict) else {}
    #     if not tblLinkPA.dataLen:
    #         # Si no se pasa tblLinkPA con datos, toma obj: fldProgrammedDate de itemsDict y Valida elementos.
    #         itemsDict = {k: v for (k, v) in itemsDict.items() if
    #                      k in cls.get_active_uids_iter() and isinstance(v, datetime)}
    #     if isinstance(paObj, paClass) and itemsDict:
    #         # 2. Create records en tblLinkPA. fldProgrammedDate MUST be supplied in args DataTable.
    #         for j, k in enumerate(itemsDict):
    #             # Creates execution instance for object k
    #             tblLinkPA.setVal(j, fldFK_Actividad=paObj.ID, fldFK=k.ID, fldProgrammedDate=itemsDict[k],
    #                              fldComment=f'Object: {k} / Activity: {activity_id}.')
    #         _ = tblLinkPA.setRecords()  # Crea los records en tblLinkPA
    #
    #         # # 3. Registra progActivity creada con cada uno de los objetos (Bovine, etc.) para los que fue definida
    #         # objList = [o for o in cls.getRegisterDict().values() if o.isActive and o.ID in itemsDict.keys()]
    #         # if objList:
    #         #     for o in objList:
    #         #         o.registerProgActivity(paObj)    # myProgActivities = {paObj: __activityID}
    #         #     return objList
    #
    #         return paObj
    #     return None


    def validateActivity(self, activityName: str):
        """
        Checks whether __activityName is defined for the class of Animal of the caller object
        @param activityName: str. Activity Name to check.
        @return: True: Activity defined for Animal - False: Activity is not defined.
        """
        activityName = activityName.strip()
        if activityName in self.__activitiesForMyClass:
            animalClassID = self.__activitiesForMyClass[activityName]
            if animalClassID == 0 or self.animalClassID() == animalClassID:
                return True
        return False

    def setMyTags(self, *args: Tag):
        retValue = []
        if args:
            for t in args:           # t is a Tag object
                if isinstance(t, Tag) and t.isAvailable:
                    self.__myTags.add(t)                        # __myTags is set(tagObject, )
                    self.__identifiers.add(t.ID)                # __identifiers = set(tagID, )
                    t.assignedToClass = type(self)
                    self.getAllAssignedTags()[t.ID] = t  # Updates dict {tagID: tagObject, } in Bovine, Caprine, etc.
                    retValue.append(t)
        return retValue

    def popMyTags(self, *args):       # Tag | str
        """
        Removes (deassigns) tags in *args from Tag list of Animal
        @param args: Tag object(s) to remove. '*': -> removes all Tags.
        @return: list of tags removed. Empty list if nothing is removed.
        """
        if args:
            retList = []
            if '*' in args:
                for i in self.__myTags:
                    # i.assignTo(None)              # Field deprecated. Not used anymore (Aug-24)
                    # self.getAllAssignedTags().pop(i.ID, None)  # Updates dict {tagNumber: tagObject, } .
                    retList.append(i)
                self.__myTags.clear()
                self.__identifiers.clear()                      # __identifiers = set(tagID, )
                return retList

            for i in args:
                if i in self.__myTags:
                    self.__myTags.remove(i)
                    self.__identifiers.discard(i.ID)           # __identifiers = set(tagID, )
                    # self.getAllAssignedTags().pop(i.ID, None)  # Updates dict {tagID: tagObject, } .
                    retList.append(i)
            return retList
        return []

    @property
    def myTags(self):
        return tuple(self.__myTags)          # Hay que hacer el set subscriptable

    @property
    def myTagNumbers(self):
        if self.__myTags:
            return tuple([j.tagNumber for j in self.__myTags])
        return ()

    @property
    def myTagIDs(self):
        if self.__myTags:
            return [j.ID for j in self.__myTags]
        return []

    @classmethod
    def IDFromTagNum(cls, tagList: str = None):
        """
        Returns an ID from passed Tag Numbers. If more than 1 tag is passed, returns a list of all the matching tags.
        @param tagList: List of Tag numbers (tagNumber attribute, str)
        @return: Dictionary {AnimalObj: [tagObj1, tagObj2, ], }  {}: no matches in Tag RegisterDict.
        """
        tagNumbers = tagList if hasattr(tagList, '__iter__') and not isinstance(tagList, str) else [tagList, ]
        matchingDict = {}
        if tagNumbers:
            cleanTagNumbers = [removeAccents(str(j)) for j in tagNumbers]                # map(removeAccents, tagList)
            matchingIDs = []
            for j in cls.getRegisterDict():                                     # List of matching indices
                indices = [cleanTagNumbers.index(tagNum) for tagNum in cls.getRegisterDict()[j].myTagNumbers]
                if indices:
                    myTags = list(cls.getRegisterDict()[j].myTags)
                    for v in range(len(myTags)):
                        if myTags[v].tagNumber in cleanTagNumbers:
                            matchingIDs.append(cls.getRegisterDict()[j].myTags[v].ID)
                    matchingDict[cls.getRegisterDict()[j]] = [Tag.getRegisterDict()[t] for t in matchingIDs]
                break    # Sale al primer match, pero podria seguir. En teoria, en un sistema integro, hay 1 solo match

        return matchingDict


    @classmethod                 # DB Trigger-related method.
    def processExecutedActivity(cls):    # cls is Bovine, Caprine, etc (see above processReplicated).
        """   ****** IMPORTANT: THIS FUNCTION IS TO BE CALLED WITH REPLICATED RECORDS ALREADY DUE FOR PROCESS.
        ALSO IMPORTANT: Leave this method here, in this class, for flexibility. If ever a specific method is required
        for class cls, it can be implemented with simple inheritance.
        Must be defined in here because it runs getObject() method which is called by Bovine, Caprine, etc. It also uses
        Activity objects from _activityObjList, which is defined in class Animal.   ********
        Uploads records from [Animales Registro De Actividades] ONLY for Animal class cls, ONLY for nodes different
        from this node (the local node) and checks if the Activities loaded can be the Closure Activity for
        ProgActivities defined in the local node (for whatever objects those ProgActivities are defined).
        @return: None
        """
        tblRADBName = getTblName(cls.tblRAName())
        # print(f'PROCESS_EXECUTED_ACTIVITY - STEP 1.')
        if strError in tblRADBName:
            return None
        sql0 = f'SELECT DB_Table_Name, TimeStamp, Last_Processing, Updated_By FROM _sys_Trigger_Tables WHERE ' \
               f'_sys_TRigger_Tables.ROWID == Flag_ROWID AND DB_Table_Name == "{tblRADBName}"; '
        # tblTriggers = dbRead('tbl_sys_Trigger_Tables', sql0)      # This reads only 1 record: the one with tblRADBName.
        con = SQLiteQuery().conn
        dfTriggers = pd.read_sql_query(sql0, con)
        # (f'PROCESS_EXECUTED_ACTIVITY - STEP 1.1')
        if dfTriggers.empty:
            # print(f'PROCESS_EXECUTED_ACTIVITY - STEP 1.2.')
            return None
        else:
            lower_lim = dfTriggers.loc[0, "fldLast_Processing"]
            upper_lim = dfTriggers.loc[0, "fldTimeStamp"]
            lower_lim = f'"{lower_lim.strftime(fDateTime)}"' if isinstance(lower_lim, datetime) else \
                time_mt('dt') - dt.timedelta(days=30)
            upper_lim = f'"{upper_lim.strftime(fDateTime)}"' if isinstance(upper_lim, datetime) else time_mt('dt')

        # Gets all tblRA records with fldTimeStamp between lower_lim and upper_lim
        # print(f'PROCESS_EXECUTED_ACTIVITY - STEP 2.')
        fld_timestamp = getFldName(cls.tblRAName(), 'fldTimeStamp')
        classID = cls.getAnimalClassID()
        sql = f'SELECT * FROM "{tblRADBName}" WHERE "{fld_timestamp}" >= {lower_lim} AND ' \
              f'"{fld_timestamp}" <= {upper_lim} AND "{getFldName(cls.tblRAName(), "fldTerminal_ID")}" != ' \
              f'"{TERMINAL_ID}" AND "{getFldName(cls.tblRAName(), "fldFK_ClaseDeAnimal")}" == {classID}; '
        # temp = dbRead(cls.tblRAName(), sql)
        dftemp = pd.read_sql_query(sql, con)
        # print(f'PROCESS_EXECUTED_ACTIVITY - STEP 3.')
        if dftemp.empty:
            print(f'PROCESS_EXECUTED_ACTIVITY - 3.1 - tbrRA dataList:\n{dftemp.to_dict()}')
            return None

        print(f'PROCESS_EXECUTED_ACTIVITY - STEP 3.2')
        RA_records = dftemp['fldID'].tolist()
        for i in RA_records:
            print(f'PROCESS_EXECUTED_ACTIVITY - STEP 4.')
            # 2.Pulls the Activity obj from _activityObjList using activityID: a full-fledged Activity object,thank God.
            # TODO: Does this logic preclude the use of Generic Activities?? See that they can be used!
            activityID = dftemp.loc[i, 'fldFK_NombreActividad']
            # Pulls Activity object from existing cls._activityObjList.
            activityObj = next((a for a in cls._activityObjList if a._activityID == activityID), None)
            if activityObj is None:
                continue        # If activityID is not defined for cls, ignores and goes to next fldID.

            # 3. Get the object(s) for which Activity was executed (a list of 1 or more outerObjects).
            sql_link = f'SELECT * FROM "{getTblName(cls.tblLinkName())}" WHERE ' \
                       f'"{getFldName(cls.tblLinkName(), "fldFK_Actividad")}" == {i}; '
            # tblLink = dbRead(cls.tblLinkName(), sql_link)
            dfLink = pd.read_sql_query(sql_link, con)
            if dfLink.empty:
                continue

            uidCol = dfLink['fldFK'].tolist()     # List of Animal objects on which the Activity was performed.
            for j, uid in enumerate(uidCol):
                outer_obj = cls.getObject(uid)          # cls here is Bovine, Caprine, etc. No way around it.
                if not outer_obj:
                    continue
                # 4. Get execution date and other Execute DAta from execute_fields. Also excluded_fields for object j.
                # execute_fields = tblLink.getVal(j, 'fldExecuteData')            # This is a dict.
                # excluded_fields = tblLink.getVal(j, 'fldExcludedFields') or activityObj._excluded_fields  #  a list.
                execute_fields, excluded_fields = dfLink.loc[j, ('fldExecuteData', 'fldExcludedFields')]
                execute_date = execute_fields.get('execution_date', None)
                if not execute_date:
                    continue        # Not a valid execution (closing) date. Cannot close.

                # 5. Run _paMatchAndClose() with all the retrieved data. TODO: When closing_status=None, the function
                # must determine the actual closing status based on execute date and ProgActivity windows
                # IMPORTANT: outer_obj MUST be passed in kwargs as the method is executed by a different thread.
                print(f'PROCESS_EXECUTED_ACTIVITY - STEP 5 - BEFORE running _paMatchAndClose(). ')
                activityObj._paMatchAndClose(i, outer_obj=outer_obj, execute_fields=execute_fields,
                                             excluded_fields=excluded_fields, closing_status=None, force_close=False)
                print(f'PROCESS_EXECUTED_ACTIVITY - STEP 5.1 - AFTER running _paMatchAndClose(). ')
        return None

    # ---------------------------------------- Animal Activity Objects ---------------------------------------- #

    __altaObj = AltaActivityAnimal()   # Special object to call AltaActivityAnimal object bounded to a class (cls).
    @classmethod
    def alta(cls, *args, **kwargs):
        """ Interface to run class methods passing cls as outerObject parameter, instead of self.
           Executes the Alta Operation for Animales. Can perform batch altaMultiple() for multiple idRecord.
           Intended to be used with map(): pass a list of animalClassName, tipoDeAlta, tags, a list of DataTables and
           kwargs enclosed in a list for each Animal to map()
           @param tags: Tag object(s) to assign to new Animal object.
           @param tipo_de_alta: 'Nacimiento', 'Compra', etc.
           @param animalKind: string! Kind of Animal to create Objects ('Vacuno','Caprino','Ovino','Porcino','Equino')
           or cls when called via Animal Class.
           @param animalMode: Tipo de Alta (string Name) from table tblAnimalesTiposDeAltaBaja
           @param mother_obj: Object pointing to the mother of the new Animal, if tipo_de_alta is Nacimiento.
           @param args: DataTable objects with obj_data to insert in DB tables, as part of the Alta operation
                        If multiple owners for 1 Animal, 1 DataTable object must be passed for each owner of the Animal
                        with the structure of table [Data Animales Actividad Personas]
           @param kwargs: additional args for tblAnimales and other uses. Can include fields for other tables if needed.
                   Special kwargs (none are mandatory):
                       animalMode='regular' (Default), 'substitute', 'dummy', 'external', 'generic'.
                       recordInventory=1 -> Activity must be counted as Inventory
                       eventDate=Date of Activity. getNow() if not provided.
                       tags = [tagObj1, tagObj1, ]. List of Tag Objects. Tags are MANDATORY for regular and substitute
                       animals
                       tagCommissionType: 'Comision' (Default), 'Comision - Reemplazo', 'Comision - Reemision'
           @return: Animal Object (Bovine, Caprine, Ovine, etc) or errorCode (str)
           """
        cls.__altaObj.outerObject = cls
        return cls.__altaObj(*args, **kwargs)       # alta() ->executes __call__(*args, **kwargs) in AltaActivityAnimal.



    #
    # __inventoryObj = InventoryActivityAnimal()          # Singleton object.
    # @property
    # def inventory(self):    # En cada llamada se setea el valor del Objecto LLamador para acceder a sus atributos
    #     self.__inventoryObj.outerObject = self   # obj.__inventoryObj.__setattr__('obj.__outerAttr', obj)
    #     return self.__inventoryObj  # Retorna objeto __inventoryObj para acceder metodos en InventoryActivityAnimal




    # -------------------- Bkgd Methods. Run by background threads (mainly, but not necessarily) --------------------- #

    @classmethod
    def updateCategories_bkgd(cls, **kwargs):       # cls is Bovine, Caprine, etc. Animal class.
        """
        Background method to update category for Bovines. Called by krnl_threading module, executed in a Timer thread.
        Daemon Function.
         @param kwargs: multiplier: True, multiplies time values by SPD (86400) in function category.update()
        @return: List of objects with category changed, or empty list if none changed.
        """
        counter = 0
        local_uids = cls.category_classmethod().get_local_uids_dict().get(cls)   # {AnimalClass: {uid: DataMemory object, }, }
        if local_uids:
            # print(f'----------- Hey 1, inside updateCategories_bkgd!. len(local_uids) = {len(local_uids)}')
            for frame in cls.get_active_uids_iter():
                # print(f'----------- Hey 2, inside updateCategories_bkgd!. local_uid[{uid}] = {local_uids[uid].record}')
                for uid in frame:
                    initial_cat = local_uids[uid].record.get('fldFK_Categoria', None)
                    retValue = None
                    if initial_cat:      # Calls compute with class Bovine, Caprine, etc. using category_classmethod() classmethod.
                        retValue = cls.category_classmethod()._compute(initial_category=initial_cat, uid=uid, verbose=True, **kwargs)
                        if retValue != initial_cat:
                            print(f'----------- Hey 3, inside updateCategories_bkgd! initial: {initial_cat} / computed cat: {retValue}')
                            animalObj = cls.getObject(uid)    # If category != initial_cat, creates object and updates category.
                            if animalObj:
                                animalObj.category.set(category=retValue)
                                bkgd_logger.info(f'@@@@@@@@@@ Updated category for animal {animalObj.recordID} to '
                                                 f'{cls.category_classmethod().category_names().get(retValue)}')
                                counter += 1  # TODO: este retorno provisorio, debugging purposes. ELIMINAR.
                            return retValue

                if not initial_cat or not retValue:
                    # Attemps to pull category from db.
                    try:  # TODO(cmt): try Contempla si active_uids_dict cambia (desde otro thread) durante la ejecucion,
                          #  para evitar el copy() de dict get_active_uids_iter
                        animalObj = cls.getObject(uid)
                        if animalObj and animalObj.isValid and (animalObj.isRegular or animalObj.isSubstitute):
                            # Importante: los calls deben ir dentro del try ->Si durante la ejecucion falla debido a que
                            # el foreground modifica la estructura aqui accedida, ignora y sigue con el siguente j.
                            retValue = animalObj.category._compute(initial_category=initial_cat, verbose=True, **kwargs)  # llama c/ objeto de clase correcta (Bovine,etc)
                            bkgd_logger.info(f'@@@@@@@@@@ Updated category for animal {animalObj.recordID} to '
                                             f'{cls.category_classmethod().category_names().get(retValue)}')
                            counter += 1  # TODO: este retorno provisorio, debugging purposes. ELIMINAR.
                    except (AttributeError, TypeError, NameError, ValueError, KeyError):
                        continue    # Va al proximo item de localRegister.
        return counter      # return retValue              # counter = numero de animales procesados.
    updateCategories_bkgd.localRegister = {}


    __dbWriteCounter = 0
    @classmethod
    def updateTimeout_bkgd(cls, **kwargs):      # cls is Bovine, Caprine, etc.
        """
        Background method to update Timeout for Bovines. Called by krnl_threading module, executed in a Timer thread.
        Daemon Function.
        @param items: List of Animal UIDs to check timeout on.
        @param kwargs: mutiplier: True, multiplies time values by SPD (86400) in function updateTimeout()
        @return:
        """
        localRegister = cls.get_active_uids_iter().copy()  # Instant-copy of uids_dict to manage simultaneous access
        # now = datetime.now()
        counter = 0
        for uid in localRegister:
            # Computes timeout WITHOUT loading up Animal objects. Creates Animal object only for animals with timeout.
            # print(f'cls.inventory_obj is : {cls.inventory_obj}')
            # inventory_obj() is a classmethod that sets cls as outerObject and returns Activity object
            # last_inv_record = cls.inventory_obj().get(uid=uid, full_record=True)
            # last_inv = last_inv_record['fldDate']
            # days_to_timeout = last_inv_record.get('fldDaysToTimeout') or cls._defaultDaysToTimeout
            # if (now - last_inv).days > days_to_timeout:
            days_since_inv = cls.category_classmethod()._check_timeout(uid=uid)  # Uses inventory_obj() to pass cls as outerObject

            if days_since_inv:
                # Goes to create an object for Animals in timeout.
                j = cls.getObject(uid)

                # print(f'------- updateTimeout_bkgd() Animal: {j.recordID} / Last Inventory: {last_inv}')
                # print(f'obj: {j}')
                try:      # TODO(cmt): Contempla si cls._memory_data_classes() cambia (desde otro thread) durante la ejecucion.
                    if j.isRegular or j.isSubstitute:
                        # print(f'5555555555 I"m in updateTimeout_bkgd() now, with timed-out animal {j}.')
                        # Importante meter el call de abajo dentro del try -> Si durante la ejecucion falla debido a que
                        # el foreground modifica la estructura accedida por este call, ignora y sigue con el siguente j.
                        var = (j, j.inventory.get())
                        # krnl_logger.debug(f'======> Animal: {var[0].recordID}, lastInv: {var[1]}')
                        # a = j.updateTimeout(last_inventory=last_inv, **kwargs)  # Calls updateTimeout() in entityObject.Same method for all EO.

                        # print(f'THE object IS: {j}')
                        # cls.__dbWriteCounter += 1
                        # if cls.__dbWriteCounter == 1000:  # TODO: Prueba de escritura en DB desde este thread
                        #     cls.__dbWriteCounter = 0
                        #   # TODO(cmt):Estos writes son solo para code testing.Desde bkdg SIEMPRE usar try/except en writes
                        #     j.inventory.set()       # Escribe en DB
                        #     j.inventory.get()
                        # print(f' &&&&&&&&&{moduleName()}({lineNum()}), {callerFunction(getCallers=False)}: '
                        #       f'INSIDE updateTimeout_bkgd()   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&')

                        cls.getBkgdAnimalTimeouts().append(var)
                        bkgd_logger.info(f'Timeout for animal {var[0]}({var[0].recordID}): Last inventory: {var[1]} / '
                                         f'Elapsed days: {days_since_inv}.')
                        counter += 1  # Retorna cantidad de animales procesados, for debugging/timing purposes.
                        # retValue = True  # Indica que se agregaron items en Timeout a la lista
                        del j
                except (AttributeError, TypeError, NameError, ValueError, KeyError):
                    continue    # Va al proximo item de localRegister.

        # return retValue
        return counter
    updateTimeout_bkgd.localRegister = {}


# =============================================== End class Animal ================================================== #

# =================================================================================================================== #


class Mammal(Animal):
    __objClass = 4
    __objType = 1
    __myTagClass = TagMammal            # Abstract class
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @classmethod
    def _tagCreatorClass(cls):
        return cls.__myTagClass

class Birds(Animal):
    __objClass = 6
    __objType = 1
    __myTagClass = TagBird           # Abstract class

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @classmethod
    def _tagCreatorClass(cls):
        return cls.__myTagClass
